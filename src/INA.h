/*!
@file INA.h

@brief INA Class library header file

@mainpage Arduino library to support the INAxxx family of current sensors

@section Library_intro_section Description

Class definition header for the INA class. This library gives a common interface to various INA power monitor
devices, see https://github.com/SV-Zanshin/INA/wiki or the code below for a full list of currently supported
devices.  The INA devices have a 3-5V power supply and, depending upon the model, can measure voltages up to
26V or 36V. They are devices with High-Side / Low-Side Measurement, Bi-Directional Current and Power Monitor
with I2C Compatible Interface. The device documentation can be found at the following location:\n
http://www.ti.com/amplifier-circuit/current-sense/power-current-monitors/products.html\n\n
Detailed library descriptions are on the INA GitHub Wiki pages at https://github.com/SV-Zanshin/INA/wiki\n\n
The INA devices, apart from the INA250 and INA260, require an external shunt of known resistance to be placed
across the high-side or low-side supply or ground line and they use the small current generated by the shunt
to compute the amperage passing across the circuit.  This value, coupled with the voltage measurement, allows
the amperage and wattage to be computed by the INA device and these values can be read from the decives using
the industry standard I2C protocol.

@section license GNU General Public License v3.0

This program is free software : you can redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
option) any later version.This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.You should have received a copy of the GNU General Public License
along with this program(see https://github.com/SV-Zanshin/INA/blob/master/LICENSE).  If not, see
<http://www.gnu.org/licenses/>.

@section author Author

Written by Arnd\@SV-Zanshin

@section versions Changelog

Version | Date       | Developer                      | Comments
------- | ---------- | ------------------------------ | --------
1.0.8   | 2019-01-20 | https://github.com/Sv-Zanshin  | Issues #38. Add getDeviceAddress() function
1.0.7   | 2019-01-20 | https://github.com/Sv-Zanshin  | Issues #36 & #37. Changed for Travis-CI and automated doxygen
1.0.7   | 2018-12-27 | https://github.com/Sv-Zanshin  | Issue #33. Change program documentation to doxygen format
1.0.6   | 2018-12-13 | https://github.com/delboy711   | Issue #32. Incorrect ESP2866 rather than ESP8266
1.0.6   | 2018-10-19 | https://github.com/Sv-Zanshin  | Issue #31. Use full 0-32V Range on INA219 all the time
1.0.6   | 2018-10-19 | https://github.com/Sv-Zanshin  | Issue #30. Added TEENSY support & support large EEPROM
1.0.6   | 2018-10-14 | https://github.com/Sv-Zanshin  | Added correct wire handling for ESP8266 and ESP32
1.0.6   | 2018-10-07 | https://github.com/Sv-Zanshin  | Optimized getBusRaw() and getShuntRaw() functions
1.0.5   | 2018-10-04 | https://github.com/Sv-Zanshin  | Added getBusRaw() and getShuntRaw() functions
1.0.5   | 2018-09-29 | https://github.com/Sv-Zanshin  | Reformatted comments to different c++ coding style
1.0.4   | 2018-09-22 | https://github.com/Sv-Zanshin  | Issue #27. EEPROM Calls don't work with ESP32
1.0.4   | 2018-09-19 | https://github.com/Sv-Zanshin  | Issue #28. Overflow error when >31Amps specified in begin()
1.0.3   | 2018-09-04 | https://github.com/delboy711   | Issue #26. Incorrect INA3221 negative current readings
1.0.3   | 2018-08-18 | https://github.com/SV-Zanshin  | Issue #22. Reduce EEPROM Footprint
1.0.3   | 2018-08-18 | https://github.com/SV-Zanshin  | Issue #21. Rename I2C Constants to avoid redefinition STM32F1
1.0.2   | 2018-07-22 | https://github.com/SV-Zanshin  | Issue #11. Reduce EEPROM footprint. Removed "deviceName", 8B. Changed datatype in structure to bit - level length definitions, saving additional 3 bytes
1.0.2   | 2018-07-21 | https://github.com/avaldeve    | Issue #12. Incorrect const datatype for I2C Speeds
1.0.2   | 2018-07-12 | https://github.com/coelner     | Issue #9. Esplora doesn't accept "Wire.begin()"
1.0.2   | 2018-07-08 | https://github.com/SV-Zanshin  | Issue #2. Finished testing INA3221 across all functions
1.0.2   | 2018-07-07 | https://github.com/dnlwgnd     | Issue #4. Guard code used incorrect label
1.0.2   | 2018-06-30 | https://github.com/SV-Zanshin  | Issue #3. Adding faster I2C bus support
1.0.2   | 2018-06-29 | https://github.com/SV-Zanshin  | Issue #2. Adding INA3221 support to library
1.0.2   | 2018-06-29 | https://github.com/SV-Zanshin  | Issue #2. Adding INA3221 support to library
1.0.1   | 2018-06-24 | https://github.com/SV-Zanshin  | Removed extraneous elements from ina structure, optimzed code
1.0.1b  | 2018-06-23 | https://github.com/SV-Zanshin  | Fixed error on multiple devices with ina structure contents
1.0.1a  | 2018-06-23 | https://github.com/SV-Zanshin  | Removed debug mode and code
1.0.0   | 2018-06-22 | https://github.com/SV-Zanshin  | Initial release
1.0.0b  | 2018-06-17 | https://github.com/SV-Zanshin  | Continued coding, tested on INA219 and INA226
1.0.0a  | 2018-06-10 | https://github.com/SV-Zanshin  | Initial coding began

*/

/* Use old library if IDE is prior to V1.0 */
#if ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif
#ifndef INA__Class_h   // Guard code definition
  #define INA__Class_h // Define the name inside guard code

  /*****************************************************************************************************************
  ** Declare structures and enumerated types used in the class                                                    **
  *****************************************************************************************************************/
  /**
  * inaEEPROM structure type definition contains a packed bit-level definition of information stored per device
  */
  typedef struct {
    uint8_t  type                 : 4; ///< Values 0-15, see enumerated "ina_Type" for details
    uint8_t  operatingMode        : 4; ///< Values 0-15, Default to continuous mode
    uint32_t address              : 7; ///< Values 0-127, I2C Address of device
    uint32_t maxBusAmps           : 7; ///< Values 0-127, Store initialization value
    uint32_t microOhmR            :20; ///< Values 0-1.048.575, Store initialization value
  } inaEEPROM; // of structure
  /**
  * inaDet structure type definition contains a packed bit-level definition of information stored on a device
  */
  typedef struct inaDet : inaEEPROM 
  {
    uint8_t  busVoltageRegister   : 3; ///< 0- 7, Bus Voltage Register
    uint8_t  shuntVoltageRegister : 3; ///< 0- 7, Shunt Voltage Register
    uint8_t  currentRegister      : 3; ///< 0- 7, Current Register
    uint16_t shuntVoltage_LSB;         ///< Device dependent LSB factor
    uint16_t busVoltage_LSB;           ///< Device dependent LSB factor
    uint32_t current_LSB;              ///< Amperage LSB
    uint32_t power_LSB;                ///< Wattage LSB
    inaDet();                          ///< struct constructor
    inaDet(inaEEPROM inaEE);           ///< for ina = inaEE; assignment
  } inaDet; // of structure
  /**
  * ina_Type enumerated list detailing the names of all supported INA devices. The INA3221 is stored as 3 distinct
  * devices each with their own enumerated type.
  */
  enum ina_Type { INA219, INA226, INA230, INA231, INA260, INA3221_0, INA3221_1, INA3221_2, INA_UNKNOWN };
  /**
  * ina_mode enumerated list detailing the operating modes of a given device
  */
  enum ina_Mode 
  { 
    INA_MODE_SHUTDOWN,         ///< Device powered down
    INA_MODE_TRIGGERED_SHUNT,  ///< Triggered shunt, no bus
    INA_MODE_TRIGGERED_BUS,    ///< Triggered bus, no shunt
    INA_MODE_TRIGGERED_BOTH,   ///< Triggered bus and shunt
    INA_MODE_POWER_DOWN,       ///< shutdown or power-down
    INA_MODE_CONTINUOUS_SHUNT, ///< Continuous shunt, no bus
    INA_MODE_CONTINUOUS_BUS,   ///< Continuous bus, no shunt
    INA_MODE_CONTINUOUS_BOTH   ///< Both continuous, default value
  }; // of enumerated type

  /*****************************************************************************************************************
  ** Declare constants used in the class                                                                          **
  *****************************************************************************************************************/
  #ifndef I2C_MODES   // I2C related constants
    #define I2C_MODES // Guard code to prevent multiple definitions
    const uint32_t INA_I2C_STANDARD_MODE        =  100000; ///< Default normal I2C 100KHz speed
    const uint32_t INA_I2C_FAST_MODE            =  400000; ///< Fast mode
    const uint32_t INA_I2C_FAST_MODE_PLUS       = 1000000; ///< Really fast mode
    const uint32_t INA_I2C_HIGH_SPEED_MODE      = 3400000; ///< Turbo mode
  #endif
  const uint8_t  INA_CONFIGURATION_REGISTER     =       0; ///< Configuration Register address
  const uint8_t  INA_BUS_VOLTAGE_REGISTER       =       2; ///< Bus Voltage Register address
  const uint8_t  INA_POWER_REGISTER             =       3; ///< Power Register address
  const uint8_t  INA_CALIBRATION_REGISTER       =       5; ///< Calibration Register address
  const uint8_t  INA_MASK_ENABLE_REGISTER       =       6; ///< Mask enable Register address (not on all devices)
  const uint8_t  INA_ALERT_LIMIT_REGISTER       =       7; ///< Alert Limit Register address (not on all devices)
  const uint8_t  INA_MANUFACTURER_ID_REGISTER   =    0xFE; ///< Manuf. ID Register address (not on all devices)
  const uint8_t  INA_DIE_ID_REGISTER            =    0xFF; ///< Die ID Register address (not on all devices)
  const uint16_t INA_RESET_DEVICE               =  0x8000; ///< Write to configuration to reset device
  const uint16_t INA_CONVERSION_READY_MASK      =  0x0080; ///< Bit 4
  const uint16_t INA_CONFIG_MODE_MASK           =  0x0007; ///< Bits 0-3
  const uint16_t INA_ALERT_MASK                 =  0x03FF; ///< Mask off bits 0-9
  const uint8_t  INA_ALERT_SHUNT_OVER_VOLT_BIT  =      15; ///< Register bit
  const uint8_t  INA_ALERT_SHUNT_UNDER_VOLT_BIT =      14; ///< Register bit
  const uint8_t  INA_ALERT_BUS_OVER_VOLT_BIT    =      13; ///< Register bit
  const uint8_t  INA_ALERT_BUS_UNDER_VOLT_BIT   =      12; ///< Register bit
  const uint8_t  INA_ALERT_POWER_OVER_WATT_BIT  =      11; ///< Register bit
  const uint8_t  INA_ALERT_CONVERSION_RDY_BIT   =      10; ///< Register bit
  const uint8_t  INA_DEFAULT_OPERATING_MODE     =    B111; ///< Default continuous mode
  const uint8_t  INA219_SHUNT_VOLTAGE_REGISTER  =       1; ///< INA219 Shunt Voltage Register
  const uint8_t  INA219_CURRENT_REGISTER        =       4; ///< INA219 Current Register
  const uint16_t INA219_BUS_VOLTAGE_LSB         =     400; ///< INA219 LSB in uV *100 4.00mV
  const uint16_t INA219_SHUNT_VOLTAGE_LSB       =     100; ///< INA219 LSB in uV *10  10.0uV
  const uint16_t INA219_CONFIG_AVG_MASK         =  0x07F8; ///< INA219 Bits 3-6, 7-10
  const uint16_t INA219_CONFIG_PG_MASK          =  0xE7FF; ///< INA219 Bits 11-12 masked
  const uint16_t INA219_CONFIG_BADC_MASK        =  0x0780; ///< INA219 Bits 7-10  masked
  const uint16_t INA219_CONFIG_SADC_MASK        =  0x0038; ///< INA219 Bits 3-5
  const uint8_t  INA219_BRNG_BIT                =      13; ///< INA219 Bit for BRNG in config register
  const uint8_t  INA219_PG_FIRST_BIT            =      11; ///< INA219 first bit of Programmable Gain
  const uint8_t  INA226_SHUNT_VOLTAGE_REGISTER  =       1; ///< INA226 Shunt Voltage Register
  const uint8_t  INA226_CURRENT_REGISTER        =       4; ///< INA226 Current Register
  const uint16_t INA226_BUS_VOLTAGE_LSB         =     125; ///< INA226 LSB in uV *100 1.25mV
  const uint16_t INA226_SHUNT_VOLTAGE_LSB       =      25; ///< INA226 LSB in uV *10  2.5uV
  const uint16_t INA226_CONFIG_AVG_MASK         =  0x0E00; ///< INA226 Bits 9-11
  const uint16_t INA226_DIE_ID_VALUE            =  0x2260; ///< INA226 Hard-coded Die ID for INA226
  const uint16_t INA226_CONFIG_BADC_MASK        =  0x01C0; ///< INA226 Bits 6-8 masked
  const uint16_t INA226_CONFIG_SADC_MASK        =  0x0018; ///< INA226 Bits 3-4
  const uint8_t  INA260_SHUNT_VOLTAGE_REGISTER  =       0; ///< INA260 Register doesn't exist on device
  const uint8_t  INA260_CURRENT_REGISTER        =       1; ///< INA260 Current Register
  const uint16_t INA260_BUS_VOLTAGE_LSB         =     125; ///< INA260 LSB in uV *100 1.25mV
  const uint16_t INA260_CONFIG_BADC_MASK        =  0x01C0; ///< INA260 Bits 6-8  masked
  const uint16_t INA260_CONFIG_SADC_MASK        =  0x0038; ///< INA260 Bits 3-5  masked
  const uint8_t  INA3221_SHUNT_VOLTAGE_REGISTER =       1; ///< INA3221 Register number 1
  const uint16_t INA3221_BUS_VOLTAGE_LSB        =     800; ///< INA3221 LSB in uV *100 8mV
  const uint16_t INA3221_SHUNT_VOLTAGE_LSB      =     400; ///< INA3221 LSB in uV *10  40uV
  const uint16_t INA3221_CONFIG_BADC_MASK       =  0x01C0; ///< INA3221 Bits 7-10  masked
  const uint8_t  INA3221_MASK_REGISTER          =     0xF; ///< INA32219 Mask register
  const uint8_t  I2C_DELAY                      =      10; ///< Microsecond delay on I2C writes
  /*****************************************************************************************************************
  ** Declare class header                                                                                         **
  *****************************************************************************************************************/
  /// @brief Master Library class
  class INA_Class {
    public:
      /// @brief Class Constructor (unused)
      INA_Class();
      /// @brief Class Destructor (unused)
      ~INA_Class();
      /// @brief Class initializer
      /// @details Instantiates the class. Searches the I2C bus for all INAxxx devices and set the same maxBusAmps and
      ///         microOhmR values for all of them. If the optional third parameter, devNo, is specified that specific
      ///         device gets the two specified values set for it. Can be called multiple times, but the 3 parameter
      ///         version will only function after the 2 parameter version finds all devices
      /// @param[in] maxBusAmps Integer value holding the maximum expected bus amperage, this value is used to 
      ///                       compute a device's internal power register
      /// @param[in] microOhmR Shunt resistance in micro-ohms, this value is used to compute a device's internal 
      ///                      power register
      /// @param[in] deviceNumber Device number to explicitly set the maxBusAmps and microOhmR values, by default
      ///                         all devices found get set to the same initial values for these 2 parameters
      /// @return The integer number of INAxxxx devices found on the I2C bus
      uint8_t begin (const uint8_t  maxBusAmps, const uint32_t microOhmR, const uint8_t  deviceNumber = UINT8_MAX );

      /// @brief Adjust the I2C bus speed
      /// @details I2C allows various bus speeds, see the enumerated type I2C_MODES for the standard speeds. The valid
      ///         speeds are  100KHz, 400KHz, 1MHz and 3.4MHz. Default to 100KHz when not specified.
      /// @param[in] i2cSpeed [optional] changes the I2C speed to the rate specified in Herz
      void setI2CSpeed (const uint32_t i2cSpeed = INA_I2C_STANDARD_MODE);

      /// @brief Set the INA monitoring mode
      /// @details The ina_Mode enumerated type describes the various modes which INA devices can be set to.
      /// @param[in] mode enumerated mode for the INA device
      /// @param[in] deviceNumber [optional] When specified, only that specified device number gets changed, otherwise all
      ///                     devices are set to the same mode
      void setMode (const uint8_t  mode, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA averaging mode
      /// @details INA devices can have up to an averaging rate of 1024. 
      /// @param[in] averages The number of averages taken by the INA device per measurement
      /// @param[in] deviceNumber [optional] When specified, only that specified device number gets changed, otherwise all
      ///                     devices are set to the same averaging rate
      void setAveraging (const uint16_t averages, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA bus conversion rate in microseconds
      /// @details INA devices can have a conversion rate of up to 68100 microseconds.
      /// @param[in] convTime The conversion time in microseconds, invalid values are rounded to the nearest valid value
      /// @param[in] deviceNumber [optional] When specified, only that specified device number gets changed, otherwise all
      ///                     devices are set to the same averaging rate
      void setBusConversion(const uint32_t convTime, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA shunt conversion rate in microseconds
      /// @details INA devices can have a shunt conversion rate of up to 68100 microseconds.
      /// @param[in] convTime The conversion time in microseconds, invalid values are rounded to the nearest valid value
      /// @param[in] deviceNumber [optional] When specified, only that specified device number gets changed, otherwise all
      ///                     devices are set to the same averaging rate
      void setShuntConversion (const uint32_t convTime, const uint8_t  deviceNumber = UINT8_MAX);

      /// @brief Read the last INA bus millivolt value from the specified device
      /// @details The converted millivolt value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in]  deviceNumber Device number
      /// @return integer value of bus voltage returned in millivolts
      uint16_t getBusMilliVolts (const uint8_t deviceNumber = 0);

      /// @brief Read the last INA raw value from the specified device
      /// @details The raw measured value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in] deviceNumber Device number
      /// @return integer raw value of bus voltage reading
      uint16_t getBusRaw (const uint8_t deviceNumber = 0);

      /// @brief Read the last INA shunt microvolt value from the specified device
      /// @details The converted microvolt value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in] deviceNumber Device number
      /// @return integer value of shunt voltage returned in microvolts
      int32_t getShuntMicroVolts (const uint8_t deviceNumber = 0);

      /// @brief Read the last INA shunt raw value from the specified device
      /// @details The raw shunt measured value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in] deviceNumber Device number
      /// @return integer raw value of shunt voltage reading
      int16_t getShuntRaw (const uint8_t deviceNumber = 0);

      /// @brief Read the last INA bus microamps value from the specified device
      /// @details The converted bus microamps value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in] deviceNumber Device number
      /// @return integer value of bus voltage returned in microamps
      int32_t getBusMicroAmps (const uint8_t deviceNumber = 0);

      /// @brief Read the last INA bus microwatts value from the specified device
      /// @details The converted bus microwatts value is returned and if the device is in triggered mode the next
      ///         conversion is started
      /// @param[in] deviceNumber Device number
      /// @return integer value of bus watts returned in microwatts
      int32_t getBusMicroWatts (const uint8_t  deviceNumber = 0);

      /// @brief Return the INA device name for a device
      /// @param[in] deviceNumber Device number
      /// @return char* of the device name
      const char* getDeviceName (const uint8_t deviceNumber = 0);

      /// @brief Return the INA device address for a device
      /// @param[in] deviceNumber Device number
      /// @return unsigned 8-bit integer of the device address
      uint8_t getDeviceAddress(const uint8_t deviceNumber = 0);

      /// @brief Reset the INA device
      /// @param[in] deviceNumber Device number
      void reset (const uint8_t deviceNumber = 0);

      /// @brief Wait for the currently running INA device to finish a conversion
      /// @param[in] deviceNumber Device number
      void waitForConversion (const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when a conversion finishes
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnConversion (const bool alertState, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when shunt voltage exceeds a value
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] milliVolts Alert level at which to trigger the alarm
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnShuntOverVoltage (const bool alertState, const int32_t milliVolts, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when shunt voltage goes below a value
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] milliVolts Alert level at which to trigger the alarm
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnShuntUnderVoltage(const bool alertState, const int32_t milliVolts, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when bus voltage goes above a value
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] milliVolts Alert level at which to trigger the alarm
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnBusOverVoltage (const bool alertState, const int32_t milliVolts, const uint8_t deviceNumber = UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when bus voltage goes below a value
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] milliVolts Alert level at which to trigger the alarm
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnBusUnderVoltage (const bool alertState, const int32_t milliVolts, const uint8_t deviceNumber =UINT8_MAX);

      /// @brief Set the INA device to pull its ALERT pin low when power value goes above a value
      /// @param[in] alertState Boolean true or false to denote the requested setting
      /// @param[in] milliAmps Alert level at which to trigger the alarm
      /// @param[in] deviceNumber [optional] Device number, if not specified then all devices are set
      /// @return boolean true when the alert could be set
      bool AlertOnPowerOverLimit (const bool alertState, const int32_t milliAmps, const uint8_t deviceNumber =UINT8_MAX);

    private:
      /// @brief Read 2 bytes from the I2C bus
      /// @param[in] addr I2C address to read from
      /// @param[in] deviceAddress Address on the I2C device to read from
      /// @return integer value read from the I2C device
      int16_t readWord (const uint8_t addr, const uint8_t deviceAddress);

      /// @brief Write 2 bytes from the I2C bus
      /// @param[in] addr I2C address to read from
      /// @param[in] data Word to write to the I2C device
      /// @param[in] deviceAddress Address on the I2C device to read from
      void writeWord (const uint8_t addr, const uint16_t data, const uint8_t deviceAddress);

      /// @brief Read INA device information from EEPROM
      /// @param[in] deviceNumber Device number to retreive information from
      void readInafromEEPROM(const uint8_t deviceNumber);

      /// @brief Write INA device information to EEPROM
      /// @param[in] deviceNumber Device number to retreive information from
      void writeInatoEEPROM (const uint8_t deviceNumber);

      /// @brief Initialize INA device
      /// @param[in] deviceNumber Device number to initialize
      void initDevice (const uint8_t deviceNumber);

      uint8_t   _DeviceCount = 0;         ///< Total number of devices detected
      uint8_t   _currentINA  = UINT8_MAX; ///< Stores current INA device number
      inaEEPROM inaEE; ///< INA device structure
      inaDet    ina; ///< INA device structure
  }; // of INA_Class definition
#endif
